/* USER CODE BEGIN Header */
/**
  * Sistema de monitoreo card√≠aco con FreeRTOS
  * FSR + MAX30102 + OLED
  * Usando recursos del IOC: FSR_TASK, SensorTask, DisplayTask
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
#include "oled.h"
#include "max30102.h"
#include "heartrate.h"
#include "cardiac_monitor.h"
#include "mpu6050_detection.h"
#include "NEO_6M.h"
#include <math.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define GPS_CHECK_INTERVAL 1000
#define EMERGENCY_ALARM_PATTERN 3
#define GPS_BUFFER_SIZE 512
#define GPS_MOTION_THRESHOLD 5.0f
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc2;
ADC_HandleTypeDef hadc3;
DMA_HandleTypeDef hdma_adc1;
DMA_HandleTypeDef hdma_adc2;
DMA_HandleTypeDef hdma_adc3;

I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c2;
I2C_HandleTypeDef hi2c4;

TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;

UART_HandleTypeDef huart7;
UART_HandleTypeDef huart3;
DMA_HandleTypeDef hdma_uart7_rx;

/* Definitions for defaultTask */
osThreadId_t defaultTaskHandle;
const osThreadAttr_t defaultTask_attributes = {
  .name = "defaultTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for FSRTask */
osThreadId_t FSRTaskHandle;
const osThreadAttr_t FSRTask_attributes = {
  .name = "FSRTask",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for SensorTask */
osThreadId_t SensorTaskHandle;
const osThreadAttr_t SensorTask_attributes = {
  .name = "SensorTask",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityAboveNormal,
};
/* Definitions for DisplayTask */
osThreadId_t DisplayTaskHandle;
const osThreadAttr_t DisplayTask_attributes = {
  .name = "DisplayTask",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for Mpu6050Task */
osThreadId_t Mpu6050TaskHandle;
const osThreadAttr_t Mpu6050Task_attributes = {
  .name = "Mpu6050Task",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for AlarmTask */
osThreadId_t AlarmTaskHandle;
const osThreadAttr_t AlarmTask_attributes = {
  .name = "AlarmTask",
  .stack_size = 256 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for GpsTaskHandle */
osThreadId_t GpsTaskHandleHandle;
const osThreadAttr_t GpsTaskHandle_attributes = {
  .name = "GpsTaskHandle",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityHigh,
};
/* Definitions for FSRTask2 */
osThreadId_t FSRTask2Handle;
const osThreadAttr_t FSRTask2_attributes = {
  .name = "FSRTask2",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for FSRTask3 */
osThreadId_t FSRTask3Handle;
const osThreadAttr_t FSRTask3_attributes = {
  .name = "FSRTask3",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for sensorDataQueue */
osMessageQueueId_t sensorDataQueueHandle;
const osMessageQueueAttr_t sensorDataQueue_attributes = {
  .name = "sensorDataQueue"
};
/* Definitions for MpuEventQueue */
osMessageQueueId_t MpuEventQueueHandle;
const osMessageQueueAttr_t MpuEventQueue_attributes = {
  .name = "MpuEventQueue"
};
/* Definitions for AlarmQueue */
osMessageQueueId_t AlarmQueueHandle;
const osMessageQueueAttr_t AlarmQueue_attributes = {
  .name = "AlarmQueue"
};
/* Definitions for oledMutex */
osMutexId_t oledMutexHandle;
const osMutexAttr_t oledMutex_attributes = {
  .name = "oledMutex"
};
/* Definitions for uartMutex */
osMutexId_t uartMutexHandle;
const osMutexAttr_t uartMutex_attributes = {
  .name = "uartMutex"
};
/* Definitions for stateChangeSem */
osSemaphoreId_t stateChangeSemHandle;
const osSemaphoreAttr_t stateChangeSem_attributes = {
  .name = "stateChangeSem"
};
/* USER CODE BEGIN PV */
// Handles de hardware (externos para cardiac_monitor.c)
OLED_HandleTypeDef holed;
MAX30105_t particleSensor;
uint8_t max30102_initialized=1;
// Variables para c√°lculo de ritmo card√≠aco
uint8_t rates[RATE_SIZE];
uint8_t rateSpot = 0;
uint32_t lastBeat = 0;

// Buffers para mensajes
char msg[100];

// Variables MPU6050
uint8_t mpu_alarm_active = 0;
uint32_t mpu_alarm_start = 0;

uint8_t gps_buffer[GPS_BUFFER_SIZE];
GPS_Data_t current_gps = {0};
GPS_Data_t previous_gps = {0};
GPS_PowerManager_t gps_power_manager = {0};
uint8_t gps_first_fix = 0;
uint8_t gps_vehicle_moving = 0;  // ‚¨ÖÔ∏è FLAG: 1=movimiento, 0=est√°tico

uint8_t fsr2_pressed_count = 0;
uint8_t fsr2_released_count = 0;
uint32_t fsr2_release_start = 0;
uint8_t fsr2_was_pressed = 0;

uint8_t fsr3_pressed_count = 0;   // Contador debounce presi√≥n
uint8_t fsr3_released_count = 0;  // Contador debounce liberaci√≥n
uint32_t fsr3_release_start = 0;  // Timestamp para timeout

uint8_t fsr3_active = 0;          // 1 = FSR3 presionado
uint8_t fsr1_active = 0;  // 1 = FSR1 presionado
uint8_t fsr2_active = 0;  // 1 = FSR2 presionado
uint8_t any_fsr_was_active = 0;  // Flag para detectar cambios

uint32_t last_gps_check = 0;
float last_gps_distance = 0.0f;
uint8_t gps_initialized = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_I2C1_Init(void);
static void MX_I2C2_Init(void);
static void MX_USART3_UART_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM2_Init(void);
static void MX_I2C4_Init(void);
static void MX_TIM3_Init(void);
static void MX_ADC2_Init(void);
static void MX_ADC3_Init(void);
static void MX_UART7_Init(void);
void StartDefaultTask(void *argument);
void StartFSRTask(void *argument);
void StartSensorTask(void *argument);
void StartDisplayTask(void *argument);
void StartMpu6050Task(void *argument);
void StartAlarmTask(void *argument);
void StartGpsTask(void *argument);
void StartFSRTask2(void *argument);
void StartFSRTask3(void *argument);

/* USER CODE BEGIN PFP */
void Initialize_System_Hardware(void);
void MPU_Process_Event(void);
void MPU_Activate_Alarm(void);
void MPU_Activate_AlarmAcel(void);
void Activate_Vibration(void);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */
/* USER CODE BEGIN Boot_Mode_Sequence_0 */
#if defined(DUAL_CORE_BOOT_SYNC_SEQUENCE)
  int32_t timeout;
#endif /* DUAL_CORE_BOOT_SYNC_SEQUENCE */
/* USER CODE END Boot_Mode_Sequence_0 */

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
#if defined(DUAL_CORE_BOOT_SYNC_SEQUENCE)
  /* Wait until CPU2 boots and enters in stop mode or timeout*/
  timeout = 0xFFFF;
  while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) != RESET) && (timeout-- > 0));
  if ( timeout < 0 )
  {
  Error_Handler();
  }
#endif /* DUAL_CORE_BOOT_SYNC_SEQUENCE */
/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
/* USER CODE BEGIN Boot_Mode_Sequence_2 */
#if defined(DUAL_CORE_BOOT_SYNC_SEQUENCE)
/* When system initialization is finished, Cortex-M7 will release Cortex-M4 by means of
HSEM notification */
/*HW semaphore Clock enable*/
__HAL_RCC_HSEM_CLK_ENABLE();
/*Take HSEM */
HAL_HSEM_FastTake(HSEM_ID_0);
/*Release HSEM in order to notify the CPU2(CM4)*/
HAL_HSEM_Release(HSEM_ID_0,0);
/* wait until CPU2 wakes up from stop mode */
timeout = 0xFFFF;
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) == RESET) && (timeout-- > 0));
if ( timeout < 0 )
{
Error_Handler();
}
#endif /* DUAL_CORE_BOOT_SYNC_SEQUENCE */
/* USER CODE END Boot_Mode_Sequence_2 */

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_I2C1_Init();
  MX_I2C2_Init();
  MX_USART3_UART_Init();
  MX_ADC1_Init();
  MX_TIM2_Init();
  MX_I2C4_Init();
  MX_TIM3_Init();
  MX_ADC2_Init();
  MX_ADC3_Init();
  MX_UART7_Init();
  /* USER CODE BEGIN 2 */
  Initialize_System_Hardware();
  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();
  /* Create the mutex(es) */
  /* creation of oledMutex */
  oledMutexHandle = osMutexNew(&oledMutex_attributes);

  /* creation of uartMutex */
  uartMutexHandle = osMutexNew(&uartMutex_attributes);

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* creation of stateChangeSem */
  stateChangeSemHandle = osSemaphoreNew(1, 0, &stateChangeSem_attributes);

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the queue(s) */
  /* creation of sensorDataQueue */
  sensorDataQueueHandle = osMessageQueueNew (7, 16, &sensorDataQueue_attributes);

  /* creation of MpuEventQueue */
  MpuEventQueueHandle = osMessageQueueNew (5, 16, &MpuEventQueue_attributes);

  /* creation of AlarmQueue */
  AlarmQueueHandle = osMessageQueueNew (5, 1, &AlarmQueue_attributes);

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of defaultTask */
  defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);

  /* creation of FSRTask */
  FSRTaskHandle = osThreadNew(StartFSRTask, NULL, &FSRTask_attributes);

  /* creation of SensorTask */
  SensorTaskHandle = osThreadNew(StartSensorTask, NULL, &SensorTask_attributes);

  /* creation of DisplayTask */
  DisplayTaskHandle = osThreadNew(StartDisplayTask, NULL, &DisplayTask_attributes);

  /* creation of Mpu6050Task */
  Mpu6050TaskHandle = osThreadNew(StartMpu6050Task, NULL, &Mpu6050Task_attributes);

  /* creation of AlarmTask */
  AlarmTaskHandle = osThreadNew(StartAlarmTask, NULL, &AlarmTask_attributes);

  /* creation of GpsTaskHandle */
  GpsTaskHandleHandle = osThreadNew(StartGpsTask, NULL, &GpsTaskHandle_attributes);

  /* creation of FSRTask2 */
  FSRTask2Handle = osThreadNew(StartFSRTask2, NULL, &FSRTask2_attributes);

  /* creation of FSRTask3 */
  FSRTask3Handle = osThreadNew(StartFSRTask3, NULL, &FSRTask3_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 12;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 5;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 4096;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
  PeriphClkInitStruct.PLL2.PLL2M = 4;
  PeriphClkInitStruct.PLL2.PLL2N = 10;
  PeriphClkInitStruct.PLL2.PLL2P = 2;
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
  PeriphClkInitStruct.PLL2.PLL2R = 2;
  PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_3;
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOMEDIUM;
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = DISABLE;
  hadc1.Init.Oversampling.Ratio = 1;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_15;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  sConfig.OffsetSignedSaturation = DISABLE;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief ADC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC2_Init(void)
{

  /* USER CODE BEGIN ADC2_Init 0 */

  /* USER CODE END ADC2_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC2_Init 1 */

  /* USER CODE END ADC2_Init 1 */

  /** Common config
  */
  hadc2.Instance = ADC2;
  hadc2.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
  hadc2.Init.Resolution = ADC_RESOLUTION_12B;
  hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc2.Init.LowPowerAutoWait = DISABLE;
  hadc2.Init.ContinuousConvMode = ENABLE;
  hadc2.Init.NbrOfConversion = 1;
  hadc2.Init.DiscontinuousConvMode = DISABLE;
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc2.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
  hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc2.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc2.Init.OversamplingMode = DISABLE;
  hadc2.Init.Oversampling.Ratio = 1;
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_10;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  sConfig.OffsetSignedSaturation = DISABLE;
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC2_Init 2 */

  /* USER CODE END ADC2_Init 2 */

}

/**
  * @brief ADC3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC3_Init(void)
{

  /* USER CODE BEGIN ADC3_Init 0 */

  /* USER CODE END ADC3_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC3_Init 1 */

  /* USER CODE END ADC3_Init 1 */

  /** Common config
  */
  hadc3.Instance = ADC3;
  hadc3.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
  hadc3.Init.Resolution = ADC_RESOLUTION_12B;
  hadc3.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc3.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc3.Init.LowPowerAutoWait = DISABLE;
  hadc3.Init.ContinuousConvMode = ENABLE;
  hadc3.Init.NbrOfConversion = 1;
  hadc3.Init.DiscontinuousConvMode = DISABLE;
  hadc3.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc3.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc3.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
  hadc3.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc3.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc3.Init.OversamplingMode = DISABLE;
  hadc3.Init.Oversampling.Ratio = 1;
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  sConfig.OffsetSignedSaturation = DISABLE;
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC3_Init 2 */

  /* USER CODE END ADC3_Init 2 */

}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.Timing = 0x00C0EAFF;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */

  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.Timing = 0x00C0EAFF;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}

/**
  * @brief I2C4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C4_Init(void)
{

  /* USER CODE BEGIN I2C4_Init 0 */

  /* USER CODE END I2C4_Init 0 */

  /* USER CODE BEGIN I2C4_Init 1 */

  /* USER CODE END I2C4_Init 1 */
  hi2c4.Instance = I2C4;
  hi2c4.Init.Timing = 0x00C0EAFF;
  hi2c4.Init.OwnAddress1 = 0;
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C4_Init 2 */

  /* USER CODE END I2C4_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 99;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 999;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);

}

/**
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 9999;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 2499;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  HAL_TIM_MspPostInit(&htim3);

}

/**
  * @brief UART7 Initialization Function
  * @param None
  * @retval None
  */
static void MX_UART7_Init(void)
{

  /* USER CODE BEGIN UART7_Init 0 */

  /* USER CODE END UART7_Init 0 */

  /* USER CODE BEGIN UART7_Init 1 */

  /* USER CODE END UART7_Init 1 */
  huart7.Instance = UART7;
  huart7.Init.BaudRate = 9600;
  huart7.Init.WordLength = UART_WORDLENGTH_8B;
  huart7.Init.StopBits = UART_STOPBITS_1;
  huart7.Init.Parity = UART_PARITY_NONE;
  huart7.Init.Mode = UART_MODE_TX_RX;
  huart7.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart7.Init.OverSampling = UART_OVERSAMPLING_16;
  huart7.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart7.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart7.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart7) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart7, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart7, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart7) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN UART7_Init 2 */

  /* USER CODE END UART7_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
  /* DMA2_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/**
  * @brief  Inicializa hardware del sistema
  */
void Initialize_System_Hardware(void)
{
  // Calibrar ADC
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET_LINEARITY, ADC_SINGLE_ENDED);

  // Inicializar OLED
  OLED_Init_Handle(&holed, &hi2c2, OLED_I2C_ADDR);
  if (OLED_Init(&holed) != HAL_OK)
  {
    sprintf(msg, "ERROR: OLED no inicializado!\r\n");
    HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
    Error_Handler();
  }

  OLED_Clear(&holed);
  HAL_Delay(100);

  // Pantalla de inicio
  OLED_SetCursor(&holed, 1, 10);
  OLED_PrintText(&holed, "SISTEMA");
  OLED_SetCursor(&holed, 2, 8);
  OLED_PrintText(&holed, "CARDIACO");
  OLED_SetCursor(&holed, 4, 0);
  OLED_PrintText(&holed, "FSR+MAX30102");
  OLED_SetCursor(&holed, 6, 4);
  OLED_PrintText(&holed, "Con FreeRTOS");
  HAL_Delay(2000);

  sprintf(msg, "\r\n===== SISTEMA CON FREERTOS =====\r\n");
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

  // Inicializar MAX30102
  if (!MAX30105_begin(&particleSensor, &hi2c1, MAX30105_ADDRESS))
  {
    sprintf(msg, "ERROR: MAX30102 no encontrado!\r\n");
    HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

    OLED_Clear(&holed);
    OLED_SetCursor(&holed, 2, 4);
    OLED_PrintText(&holed, "ERROR");
    OLED_SetCursor(&holed, 4, 0);
    OLED_PrintText(&holed, "MAX30102 I2C");

    while (1)
    {
      HAL_GPIO_TogglePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin);
      HAL_Delay(200);
    }
  }

  sprintf(msg, "MAX30102 OK! Rev: 0x%02X Part: 0x%02X\r\n",
          MAX30105_getRevisionID(&particleSensor),
          MAX30105_readPartID(&particleSensor));
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

  MAX30105_setup(&particleSensor, 0x1F, 4, 2, 100, 411, 4096);
  heartRate_init();
  max30102_initialized = 1;

  sprintf(msg, "Sistema listo. BPM valido: %d-%d\r\n\r\n", MIN_BPM, MAX_BPM);
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

  OLED_Clear(&holed);
  OLED_SetCursor(&holed, 0, 0);
  OLED_PrintText(&holed, "Presione FSR");
  OLED_SetCursor(&holed, 2, 0);
  OLED_PrintText(&holed, "Fuerza:");
  OLED_SetCursor(&holed, 4, 0);
  OLED_PrintText(&holed, "Estado:LEYENDO");

  // Inicializar MPU6050 en I2C3
  sprintf(msg, "\r\nInicializando MPU6050 en I2C3...\r\n");
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

  if(MPU6050_Init() != HAL_OK)  // ‚¨ÖÔ∏è Ahora s√≠ puedes verificar
  {
      sprintf(msg, "‚ùå ERROR: MPU6050 no responde!\r\n"
                   "Verifica conexiones I2C3:\r\n");
      HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
  }
  else
  {
      sprintf(msg, "‚úÖ MPU6050 OK!\r\n");
      HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
  }
  // Inicializar monitor card√≠aco
  CardiacMonitor_Init();

  // ========== INICIALIZACI√ìN GPS ==========
   sprintf(msg, "\r\n=== INICIALIZANDO GPS NEO-6M ===\r\n");
   HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

   // Validaci√≥n inicial del GPS
   if(GPS_startup_validation(&huart7, gps_buffer) == 0) {
       sprintf(msg, "‚úÖ GPS: Fix inicial obtenido\r\n");
       gps_initialized = 1;
       gps_first_fix = 1;
   } else {
       sprintf(msg, "‚ö†Ô∏è GPS: Sin fix inicial (continuando...)\r\n");
       gps_initialized = 0;
   }
   HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

   // Inicializar gestor de energ√≠a GPS
   GPS_PowerManager_Init(&gps_power_manager);

   // Iniciar recepci√≥n DMA continua
   HAL_UART_Receive_DMA(&huart7, gps_buffer, GPS_BUFFER_SIZE);

   sprintf(msg, "GPS: Recepci√≥n DMA iniciada\r\n\r\n");
   HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);

   last_gps_check = HAL_GetTick();

  HAL_Delay(500);
}

/* Redirigir printf a UART */
int _write(int file, char *ptr, int len)
{
  HAL_UART_Transmit(&huart3, (uint8_t*)ptr, len, HAL_MAX_DELAY);
  return len;
}
void MPU_Process_Event(void)
{
    MPUEvent_t event;

    if(osMessageQueueGet(MpuEventQueueHandle, &event, NULL, 0) == osOK)
    {
        if(event.sudden_movement)
        {
            //CardiacMonitor_ActivateEmergency("Caida detectada");

        	MPU_Activate_Alarm();

        	            char msg[100];
        	            sprintf(msg, "\r\n‚ö†Ô∏è CA√çDA DETECTADA - Buzzer activado\r\n");
        	            HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), 100);
        }
    }
}

/**
  * @brief  Activa alarma de emergencia (solo buzzer, sin cambiar estado)
  */
void MPU_Activate_Alarm(void)
{
    // üö® PATR√ìN DE 3 PITIDOS
    for(uint8_t i = 0; i < 3; i++)
    {
        // Encender buzzer
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 500);  // 50% duty
        HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

        osDelay(200);  // Pitido de 200ms

        // Apagar buzzer
        HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);

        if(i < 2)  // No esperar despu√©s del √∫ltimo pitido
        {
            osDelay(150);  // Pausa de 150ms entre pitidos
        }
    }
}

void MPU_Activate_AlarmAcel(void)
{
    // üö® PATR√ìN DE 5 PITIDOS
    for(uint8_t i = 0; i < 5; i++)
    {
        // Encender buzzer
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 300);  // 50% duty
        HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

        osDelay(100);  // Pitido de 100ms

        // Apagar buzzer
        HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);

        if(i < 4)  // No esperar despu√©s del √∫ltimo pitido
        {
            osDelay(100);  // Pausa de 150ms entre pitidos
        }
    }
}

void Activate_Vibration(void)
{
	// üö® PATR√ìN DE 5 PITIDOS
	    for(uint8_t i = 0; i < 5; i++)
	    {
        // Encender Vibrador
        __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, 1250);  // 50% duty
        HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);

        osDelay(1500);  // Pitido de 300ms

        // Apagar buzzer
        HAL_TIM_PWM_Stop(&htim3, TIM_CHANNEL_1);

        if(i < 4)  // No esperar despu√©s del √∫ltimo pitido
        {
            osDelay(100);  // Pausa de 100ms entre pitidos
        }
    }
}
/* USER CODE END 4 */

/* USER CODE BEGIN Header_StartDefaultTask */
/**
  * @brief  Function implementing the defaultTask thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument)
{
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_StartFSRTask */
/**
* @brief Function implementing the FSRTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartFSRTask */
void StartFSRTask(void *argument)
{
  /* USER CODE BEGIN StartFSRTask */
  uint32_t adc_value;
  float force;
  uint8_t fsr_pressed_count = 0;
  uint8_t fsr_released_count = 0;
  uint32_t fsr_release_start = 0;
  uint8_t fsr_was_pressed = 0;

  for(;;)
  {
      HAL_ADC_Start(&hadc1);
      if (HAL_ADC_PollForConversion(&hadc1, 50) == HAL_OK)
      {
          adc_value = HAL_ADC_GetValue(&hadc1);
          force = CardiacMonitor_CalculateForce(adc_value);
      }
      HAL_ADC_Stop(&hadc1);

      uint8_t is_pressed = (force > FSR_THRESHOLD);

      if(is_pressed)
      {
          fsr_pressed_count++;
          fsr_released_count = 0;
          fsr_was_pressed = 1;
          fsr_release_start = 0;

          if(fsr_pressed_count >= FSR_DEBOUNCE_COUNT)
          {
              fsr1_active = 1;  // ‚úÖ FSR1 activo

              CardiacMonitor_UpdateFSR(force, 1);

              CardiacState_t state = CardiacMonitor_GetState();

              if(state == STATE_WAITING_CONTACT && !any_fsr_was_active)
              {
                  CardiacMonitor_ChangeState(STATE_CALIBRATING);
                  any_fsr_was_active = 1;
              }

              fsr_pressed_count = 0;
          }
      }
      else if(force < FSR_RELEASE_THRESHOLD)
      {
          fsr_released_count++;
          fsr_pressed_count = 0;

          if(fsr_released_count >= FSR_DEBOUNCE_COUNT)
          {
              fsr1_active = 0;  // ‚úÖ FSR1 inactivo

              CardiacMonitor_UpdateFSR(force, 0);

              CardiacState_t state = CardiacMonitor_GetState();

              // ===== CANCELAR CALIBRACI√ìN =====
              if(state == STATE_CALIBRATING && !fsr1_active && !fsr2_active && !fsr3_active)
              {
                  CardiacMonitor_CancelCalibration();
                  CardiacMonitor_ChangeState(STATE_WAITING_CONTACT);
                  any_fsr_was_active = 0;
              }
              // ===== ANALYZING: VERIFICAR MOVIMIENTO =====
              else if(state == STATE_ANALYZING && !fsr1_active && !fsr2_active && !fsr3_active)
              {
                  // Iniciar timer solo la primera vez
                  if(fsr_release_start == 0)
                  {
                      fsr_release_start = HAL_GetTick();
                  }

                  uint32_t time_released = HAL_GetTick() - fsr_release_start;

                  // ‚è±Ô∏è Timeout de 3 segundos
                  if(time_released >= FSR_MAX_RELEASE_TIME_MS)
                  {
                      // üîç VERIFICAR SI HAY MOVIMIENTO GPS
                      if(gps_vehicle_moving)
                      {
                          // ‚ö†Ô∏è HAY MOVIMIENTO ‚Üí ALARMA
                          MPU_Activate_AlarmAcel();
                          Activate_Vibration();

                          osMutexAcquire(oledMutexHandle, osWaitForever);
                          OLED_Clear(&holed);
                          OLED_SetCursor(&holed, 2, 0);
                          OLED_PrintText(&holed, "MOVIMIENTO!");
                          OLED_SetCursor(&holed, 4, 0);
                          OLED_PrintText(&holed, "Agarre volante!");
                          osDelay(2000);
                          OLED_Clear(&holed);
                          osMutexRelease(oledMutexHandle);

                          char alert_msg[100];
                          sprintf(alert_msg, "\r\n‚ö†Ô∏è FSR1: Volante suelto CON movimiento (%.2fm)\r\n",
                                  last_gps_distance);
                          CardiacMonitor_PrintUART(alert_msg);
                      }
                      else
                      {
                          // ‚úÖ NO HAY MOVIMIENTO ‚Üí MODO BAJO CONSUMO
                          osMutexAcquire(oledMutexHandle, osWaitForever);
                          OLED_Clear(&holed);
                          OLED_SetCursor(&holed, 2, 0);
                          OLED_PrintText(&holed, "Modo Reposo");
                          OLED_SetCursor(&holed, 4, 0);
                          OLED_PrintText(&holed, "Vehiculo Detenido");
                          osDelay(1500);
                          OLED_Clear(&holed);
                          osMutexRelease(oledMutexHandle);

                          char sleep_msg[120];
                          sprintf(sleep_msg, "\r\nüí§ FSR1: Entrando en modo bajo consumo "
                                             "(sin movimiento detectado)\r\n");
                          CardiacMonitor_PrintUART(sleep_msg);

                          // Reducir frecuencia de muestreo
                          osDelay(2000);  // Delay extra antes de continuar
                      }

                      fsr_release_start = 0;
                  }
              }
              else
              {
                  fsr_release_start = 0;  // Reset si al menos uno est√° presionado
              }

              fsr_released_count = 0;
          }
      }

      osDelay(10);
  }
  /* USER CODE END StartFSRTask */
}

/* USER CODE BEGIN Header_StartSensorTask */
/**
* @brief Function implementing the SensorTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartSensorTask */
void StartSensorTask(void *argument)
{
  /* USER CODE BEGIN StartSensorTask */
  SensorData_t sensorData;
  static int16_t lastValidBPM = 0;  // ‚úÖ Mantener √∫ltimo BPM v√°lido

  for(;;)
  {
      uint32_t irValue = MAX30105_getIR(&particleSensor);

      sensorData.irValue = irValue;
      sensorData.finger_detected = (irValue >= IR_FINGER_THRESHOLD);
      sensorData.currentBPM = 0;
      sensorData.signalQuality = (irValue >= IR_FINGER_THRESHOLD) ?
                                  ((irValue / 1000) % 100) : 0;

      // ‚úÖ Mantener √∫ltimo BPM v√°lido siempre
      sensorData.avgBPM = lastValidBPM;

      if(!sensorData.finger_detected)
      {
          // ‚úÖ A√∫n sin dedo, mantener √∫ltimo BPM
          g_monitor.sensor = sensorData;
          osMessageQueuePut(sensorDataQueueHandle, &sensorData, 0, 0);
          osDelay(10);
          continue;
      }

      if(checkForBeat(irValue) == true)
      {
          uint32_t delta = HAL_GetTick() - lastBeat;
          lastBeat = HAL_GetTick();

          if(delta > 0)
          {
              float beatsPerMinute = 60000.0f / (float)delta;

              if(beatsPerMinute >= MIN_BPM && beatsPerMinute <= MAX_BPM)
              {
                  sensorData.currentBPM = (int16_t)beatsPerMinute;

                  rates[rateSpot++] = (uint8_t)beatsPerMinute;
                  rateSpot %= RATE_SIZE;

                  int sum = 0, count = 0;
                  for(uint8_t x = 0; x < RATE_SIZE; x++)
                  {
                      if(rates[x] > 0)
                      {
                          sum += rates[x];
                          count++;
                      }
                  }

                  if(count > 0)
                  {
                      sensorData.avgBPM = sum / count;
                      lastValidBPM = sensorData.avgBPM;  // ‚úÖ Guardar √∫ltimo v√°lido
                  }

                  CardiacState_t state = CardiacMonitor_GetState();

                  if(state == STATE_CALIBRATING)
                  {
                      CardiacMonitor_UpdateCalibration(sensorData.avgBPM);

                      if(CardiacMonitor_IsCalibrationComplete())
                      {
                          CardiacMonitor_ChangeState(STATE_ANALYZING);
                      }
                  }
                  else if(state == STATE_ANALYZING)
                  {
                      CardiacMonitor_UpdateBaseline(sensorData.avgBPM);

                      if(CardiacMonitor_DetectDrowsiness(sensorData.avgBPM))
                          {
                              // üö® ¬°USUARIO SE EST√Å DURMIENDO!
                              Activate_Vibration();     // Vibrar

                              // Mostrar alerta en pantalla
                              osMutexAcquire(oledMutexHandle, osWaitForever);
                              OLED_Clear(&holed);
                              OLED_SetCursor(&holed, 2, 10);
                              OLED_PrintText(&holed, "ALERTA!");
                              OLED_SetCursor(&holed, 4, 4);
                              OLED_PrintText(&holed, "Despierta!");
                              osDelay(2000);
                              OLED_Clear(&holed);
                              osMutexRelease(oledMutexHandle);
                          }

                      if(CardiacMonitor_DetectArrhythmia(sensorData.avgBPM))
                      {
                          CardiacMonitor_ActivateEmergency("Arritmia detectada");
                      }
                  }

                  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
                  osDelay(50);
                  HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET);
              }
          }
      }

      // ‚úÖ Actualizar siempre el monitor global
      g_monitor.sensor = sensorData;
      osMessageQueuePut(sensorDataQueueHandle, &sensorData, 0, 0);

      osDelay(10);
  }
  /* USER CODE END StartSensorTask */
}

/* USER CODE BEGIN Header_StartDisplayTask */
/**
* @brief Function implementing the DisplayTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartDisplayTask */
void StartDisplayTask(void *argument)
{
  /* USER CODE BEGIN StartDisplayTask */
  TickType_t lastOledUpdate = 0;
  TickType_t lastUartUpdate = 0;

  for(;;)
  {
      // Verificar cambio de estado
      if(osSemaphoreAcquire(stateChangeSemHandle, 0) == osOK)
      {
          osMutexAcquire(oledMutexHandle, osWaitForever);
          OLED_Clear(&holed);
          osDelay(10);
          osMutexRelease(oledMutexHandle);

          lastOledUpdate = 0; // Forzar actualizaci√≥n inmediata
      }

      // Actualizar pantalla
      if((osKernelGetTickCount() - lastOledUpdate) >= OLED_UPDATE_INTERVAL)
      {
          osMutexAcquire(oledMutexHandle, osWaitForever);
          CardiacMonitor_UpdateDisplay();
          osMutexRelease(oledMutexHandle);

          lastOledUpdate = osKernelGetTickCount();
      }

      // Imprimir por UART
      if((osKernelGetTickCount() - lastUartUpdate) >= UART_UPDATE_INTERVAL)
      {
          CardiacState_t state = CardiacMonitor_GetState();

          if(state == STATE_ANALYZING || state == STATE_CALIBRATING)
          {
              sprintf(msg, "[%s] BPM:%d | Base:%d | IR:%lu\r\n",
                      CardiacMonitor_GetStateName(state),
                      g_monitor.sensor.avgBPM,
                      CardiacMonitor_GetBaseline(),
                      g_monitor.sensor.irValue);
              CardiacMonitor_PrintUART(msg);
          }

          lastUartUpdate = osKernelGetTickCount();
      }

      osDelay(10);
  }
  /* USER CODE END StartDisplayTask */
}

/* USER CODE BEGIN Header_StartMpu6050Task */
/**
* @brief Function implementing the Mpu6050Task thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartMpu6050Task */
void StartMpu6050Task(void *argument)
{
  /* USER CODE BEGIN StartMpu6050Task */
  int16_t ax, ay, az;
  float accel_x_g, accel_y_g, accel_z_g, magnitude;
  MPUEvent_t event;
  char local_msg[120];

  osDelay(2000);  // Esperar inicializaci√≥n completa

  sprintf(local_msg, "\r\n[MPU6050] Tarea iniciada - Monitoreando movimientos...\r\n");
  CardiacMonitor_PrintUART(local_msg);

  for(;;)
  {
    // Leer aceler√≥metro
    MPU6050_Read_Accel(&ax, &ay, &az);

    // Convertir a [g]
    accel_x_g = (float)ax / ACCEL_SCALE;
    accel_y_g = (float)ay / ACCEL_SCALE;
    accel_z_g = (float)az / ACCEL_SCALE;

    // Calcular magnitud vectorial
    magnitude = sqrtf(accel_x_g * accel_x_g +
                      accel_y_g * accel_y_g +
                      accel_z_g * accel_z_g);

    // Detectar movimiento brusco
    if(Detect_Sudden_Movement(magnitude))
    {
    	event.sudden_movement = 1;
    	event.accel_magnitude = magnitude;
    	event.timestamp = HAL_GetTick();
      // ¬°EMERGENCIA DETECTADA!
      MPU_Activate_Alarm();

      // Enviar evento a cola
      osMessageQueuePut(MpuEventQueueHandle, &event, 0, 0);

      sprintf(local_msg, "\r\n!!! ALERTA: CAIDA DETECTADA !!!\r\n"
                         "Magnitud: %.2f g | Tiempo: %lu ms\r\n",
                         magnitude, event.timestamp);
      CardiacMonitor_PrintUART(local_msg);
    }

    osDelay(8);  // 125 Hz
  }
  /* USER CODE END StartMpu6050Task */
}

/* USER CODE BEGIN Header_StartAlarmTask */
/**
* @brief Function implementing the AlarmTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartAlarmTask */
void StartAlarmTask(void *argument)
{
  /* USER CODE BEGIN StartAlarmTask */
	  uint8_t cmd;
	  uint8_t pattern_index = 0;
	  uint8_t beep_state = 0;
	  TickType_t last_toggle = 0;
	  uint8_t active_alarm = 0;

	  for(;;)
	  {
	    // Verificar si hay nuevos comandos (sin bloquear)
	    if(osMessageQueueGet(AlarmQueueHandle, &cmd, NULL, 0) == osOK)
	    {
	      if(cmd == 0)  // ALARM_OFF
	      {
	        // Apagar alarma
	        HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
	        HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
	        active_alarm = 0;
	        pattern_index = 0;
	        beep_state = 0;
	      }
	      else if(cmd == 1)  // ALARM_EMERGENCY
	      {
	        // Activar alarma de emergencia
	        active_alarm = 1;
	        pattern_index = 0;
	        beep_state = 0;
	        last_toggle = osKernelGetTickCount();
	      }
	    }

	    // Manejar patr√≥n de alarma si est√° activa
	    if(active_alarm)
	    {
	      TickType_t now = osKernelGetTickCount();

	      // 3 pitidos = 6 transiciones (ON/OFF/ON/OFF/ON/OFF)
	      if(pattern_index < EMERGENCY_ALARM_PATTERN * 2)
	      {
	        // Patr√≥n: 200ms encendido, 150ms apagado
	        uint32_t interval = (pattern_index % 2 == 0) ? 200 : 150;

	        if((now - last_toggle) >= interval)
	        {
	          if(beep_state == 0)
	          {
	            // Encender buzzer y LED
	            __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 500);
	            HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
	            HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET);
	            beep_state = 1;
	          }
	          else
	          {
	            // Apagar buzzer y LED
	            HAL_TIM_PWM_Stop(&htim2, TIM_CHANNEL_1);
	            HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
	            beep_state = 0;
	          }

	          pattern_index++;
	          last_toggle = now;
	        }
	      }
	      else
	      {
	        // Pausa de 2 segundos antes de repetir
	        if((now - last_toggle) >= 2000)
	        {
	          pattern_index = 0;
	          last_toggle = now;
	        }
	      }
	    }

	    osDelay(10);
	  }
  /* USER CODE END StartAlarmTask */
}

/* USER CODE BEGIN Header_StartGpsTask */
/**
* @brief Function implementing the GpsTaskHandle thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartGpsTask */
void StartGpsTask(void *argument)
{
	/* USER CODE BEGIN StartGpsTask */
	  char local_msg[150];
	  float distance = 0.0f;
	  uint32_t gps_read_interval = 1000;

	  sprintf(local_msg, "\r\n[GPS] Tarea iniciada - Monitoreando movimiento...\r\n");
	  CardiacMonitor_PrintUART(local_msg);

	  osDelay(3000);  // Esperar inicializaci√≥n completa

	  for(;;)
	  {
	    // ===== PROCESAR BUFFER GPS =====
	    float new_lat, new_lon;
	    uint8_t gps_valid = Process_GPS_Buffer(gps_buffer, &new_lat, &new_lon);

	    if(gps_valid)
	    {
	      // Actualizar datos GPS actuales
	      GPS_Copy_Data(&previous_gps, &current_gps);

	      current_gps.latitude = new_lat;
	      current_gps.longitude = new_lon;
	      current_gps.valid = 1;

	      if(!gps_first_fix)
	      {
	        gps_first_fix = 1;
	        sprintf(local_msg, "[GPS] Primer fix obtenido: %.6f, %.6f\r\n",
	                new_lat, new_lon);
	        CardiacMonitor_PrintUART(local_msg);
	      }

	      // ===== DETECTAR MOVIMIENTO =====
	      if(previous_gps.valid)
	      {
	        uint8_t motion = GPS_Detect_Motion(&current_gps, &previous_gps,
	                                           GPS_MOTION_THRESHOLD, &distance);

	        gps_vehicle_moving = motion;
	        last_gps_distance = distance;

	        // Actualizar gestor de energ√≠a
	        GPS_PowerManager_Update(&gps_power_manager, motion);

	        // ===== ALERTA: MOVIMIENTO EN CALIBRACI√ìN =====
	        CardiacState_t state = CardiacMonitor_GetState();

	        if(state == STATE_CALIBRATING && motion)
	        {
	          // üö® ¬°VEH√çCULO EN MOVIMIENTO DURANTE CALIBRACI√ìN!
	          MPU_Activate_AlarmAcel();
	          Activate_Vibration();

	          sprintf(local_msg, "\r\n‚ö†Ô∏è ALERTA GPS: Movimiento detectado (%.2f m)\r\n"
	                             "Estado: CALIBRANDO - ¬°Det√©n el veh√≠culo!\r\n",
	                             distance);
	          CardiacMonitor_PrintUART(local_msg);

	          // Mostrar en pantalla
	          osMutexAcquire(oledMutexHandle, osWaitForever);
	          OLED_Clear(&holed);
	          OLED_SetCursor(&holed, 1, 0);
	          OLED_PrintText(&holed, "ALERTA GPS!");
	          OLED_SetCursor(&holed, 3, 0);
	          OLED_PrintText(&holed, "Vehiculo en");
	          OLED_SetCursor(&holed, 4, 0);
	          OLED_PrintText(&holed, "movimiento!");
	          OLED_SetCursor(&holed, 6, 0);
	          OLED_PrintText(&holed, "Detenerse!");
	          osDelay(2000);
	          OLED_Clear(&holed);
	          osMutexRelease(oledMutexHandle);
	        }
	        else if(motion)
	        {
	          sprintf(local_msg, "[GPS] Movimiento: %.2f m\r\n", distance);
	          CardiacMonitor_PrintUART(local_msg);
	        }
	      }

	      // Limpiar buffer despu√©s de procesar
	      memset(gps_buffer, 0, GPS_BUFFER_SIZE);
	      HAL_UART_Receive_DMA(&huart7, gps_buffer, GPS_BUFFER_SIZE);
	    }

	    // ===== GESTI√ìN DE ENERG√çA =====
	    if(GPS_PowerManager_ShouldSleep(&gps_power_manager) &&
	       CardiacMonitor_GetState() != STATE_ANALYZING)
	    {
	      sprintf(local_msg, "[GPS] Entrando en modo sleep (sin movimiento)\r\n");
	      CardiacMonitor_PrintUART(local_msg);

	      gps_read_interval = 5000;  // Leer cada 5 segundos
	      GPS_Enter_Sleep_Mode();
	    }
	    else
	    {
	      gps_read_interval = 1000;  // Leer cada 1 segundo
	    }

	    osDelay(gps_read_interval);
	  }
	  /* USER CODE END StartGpsTask */
}

/* USER CODE BEGIN Header_StartFSRTask2 */
/**
* @brief Function implementing the FSRTask2 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartFSRTask2 */
void StartFSRTask2(void *argument)
{
  /* USER CODE BEGIN StartFSRTask2 */
  uint32_t adc2_value;
  float force2;

  for(;;)
  {
      HAL_ADC_Start(&hadc2);
      if (HAL_ADC_PollForConversion(&hadc2, 50) == HAL_OK)
      {
          adc2_value = HAL_ADC_GetValue(&hadc2);
          force2 = CardiacMonitor_CalculateForce(adc2_value);
      }
      HAL_ADC_Stop(&hadc2);

      uint8_t is_pressed = (force2 > FSR_THRESHOLD);

      if(is_pressed)
      {
          fsr2_pressed_count++;
          fsr2_released_count = 0;
          fsr2_was_pressed = 1;
          fsr2_release_start = 0;

          if(fsr2_pressed_count >= FSR_DEBOUNCE_COUNT)
          {
              fsr2_active = 1;  // ‚úÖ FSR2 activo

              CardiacMonitor_UpdateFSR(force2, 1);

              CardiacState_t state = CardiacMonitor_GetState();

              if(state == STATE_WAITING_CONTACT && !any_fsr_was_active)
              {
                  CardiacMonitor_ChangeState(STATE_CALIBRATING);
                  any_fsr_was_active = 1;
              }

              fsr2_pressed_count = 0;
          }
      }
      else if(force2 < FSR_RELEASE_THRESHOLD)
      {
          fsr2_released_count++;
          fsr2_pressed_count = 0;

          if(fsr2_released_count >= FSR_DEBOUNCE_COUNT)
          {
              fsr2_active = 0;  // ‚úÖ FSR2 inactivo

              CardiacMonitor_UpdateFSR(force2, 0);

              CardiacState_t state = CardiacMonitor_GetState();

              if(state == STATE_CALIBRATING && !fsr1_active && !fsr2_active && !fsr3_active)
              {
                  CardiacMonitor_CancelCalibration();
                  CardiacMonitor_ChangeState(STATE_WAITING_CONTACT);
                  any_fsr_was_active = 0;
              }
              else if(state == STATE_ANALYZING && !fsr1_active && !fsr2_active && !fsr3_active)
              {
                  if(fsr2_release_start == 0)
                  {
                      fsr2_release_start = HAL_GetTick();
                  }

                  uint32_t time_released = HAL_GetTick() - fsr2_release_start;

                  if(time_released >= 1000)
                  {
                      // üîç VERIFICAR MOVIMIENTO
                      if(gps_vehicle_moving)
                      {
                          // ‚ö†Ô∏è HAY MOVIMIENTO ‚Üí ALARMA
                          MPU_Activate_AlarmAcel();
                          Activate_Vibration();

                          osMutexAcquire(oledMutexHandle, osWaitForever);
                          OLED_Clear(&holed);
                          OLED_SetCursor(&holed, 2, 0);
                          OLED_PrintText(&holed, "FSR2: Suelta");
                          OLED_SetCursor(&holed, 4, 0);
                          OLED_PrintText(&holed, "la palanca!");
                          osDelay(1500);
                          OLED_Clear(&holed);
                          osMutexRelease(oledMutexHandle);

                          char alert_msg[100];
                          sprintf(alert_msg, "\r\n‚ö†Ô∏è FSR2: Palanca suelta CON movimiento\r\n");
                          CardiacMonitor_PrintUART(alert_msg);
                      }
                      else
                      {
                          // ‚úÖ NO HAY MOVIMIENTO ‚Üí BAJO CONSUMO
                          char sleep_msg[100];
                          sprintf(sleep_msg, "\r\nüí§ FSR2: Modo reposo (sin movimiento)\r\n");
                          CardiacMonitor_PrintUART(sleep_msg);
                      }

                      fsr2_release_start = 0;
                  }
              }
              else
              {
                  fsr2_release_start = 0;
              }

              fsr2_released_count = 0;
          }
      }

      osDelay(10);
  }
  /* USER CODE END StartFSRTask2 */
}

/* USER CODE BEGIN Header_StartFSRTask3 */
/**
* @brief Function implementing the FSRTask3 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartFSRTask3 */
void StartFSRTask3(void *argument)
{
  /* USER CODE BEGIN StartFSRTask3 */
  uint32_t adc3_value;
  float force3;

  for(;;)
  {
      HAL_ADC_Start(&hadc3);
      if (HAL_ADC_PollForConversion(&hadc3, 50) == HAL_OK)
      {
          adc3_value = HAL_ADC_GetValue(&hadc3);
          force3 = CardiacMonitor_CalculateForce(adc3_value);
      }
      HAL_ADC_Stop(&hadc3);

      uint8_t is_pressed = (force3 > FSR_THRESHOLD);

      if(is_pressed)
      {
          fsr3_pressed_count++;
          fsr3_released_count = 0;
          fsr3_release_start = 0;

          if(fsr3_pressed_count >= FSR_DEBOUNCE_COUNT)
          {
              fsr3_active = 1;  // ‚úÖ FSR3 activo
              CardiacMonitor_UpdateFSR(force3, 1);

              CardiacState_t state = CardiacMonitor_GetState();

              if(state == STATE_WAITING_CONTACT && !any_fsr_was_active)
              {
                  CardiacMonitor_ChangeState(STATE_CALIBRATING);
                  any_fsr_was_active = 1;
              }

              fsr3_pressed_count = 0;
          }
      }
      else if(force3 < FSR_RELEASE_THRESHOLD)
      {
          fsr3_released_count++;
          fsr3_pressed_count = 0;

          if(fsr3_released_count >= FSR_DEBOUNCE_COUNT)
          {
              fsr3_active = 0;  // ‚úÖ FSR3 inactivo
              CardiacMonitor_UpdateFSR(force3, 0);

              CardiacState_t state = CardiacMonitor_GetState();

              if(state == STATE_CALIBRATING &&
                 !fsr1_active && !fsr2_active && !fsr3_active)
              {
                  CardiacMonitor_CancelCalibration();
                  CardiacMonitor_ChangeState(STATE_WAITING_CONTACT);
                  any_fsr_was_active = 0;
              }
              else if(state == STATE_ANALYZING)
              {
                  if(fsr3_release_start == 0)
                  {
                      fsr3_release_start = HAL_GetTick();
                  }

                  uint32_t time_released = HAL_GetTick() - fsr3_release_start;

                  if(time_released >= 1000)
                  {
                      // üîç VERIFICAR MOVIMIENTO
                      if(gps_vehicle_moving)
                      {
                          // ‚ö†Ô∏è HAY MOVIMIENTO ‚Üí ALARMA
                          MPU_Activate_AlarmAcel();
                          Activate_Vibration();

                          osMutexAcquire(oledMutexHandle, osWaitForever);
                          OLED_Clear(&holed);
                          OLED_SetCursor(&holed, 2, 0);
                          OLED_PrintText(&holed, "Agarre FSR3!");
                          OLED_SetCursor(&holed, 4, 0);
                          OLED_PrintText(&holed, "Volante suelto");
                          osDelay(1500);
                          OLED_Clear(&holed);
                          osMutexRelease(oledMutexHandle);

                          char alert_msg[100];
                          sprintf(alert_msg, "\r\n‚ö†Ô∏è FSR3: Volante suelto CON movimiento\r\n");
                          CardiacMonitor_PrintUART(alert_msg);
                      }
                      else
                      {
                          // ‚úÖ NO HAY MOVIMIENTO ‚Üí BAJO CONSUMO
                          char sleep_msg[100];
                          sprintf(sleep_msg, "\r\nüí§ FSR3: Modo reposo (sin movimiento)\r\n");
                          CardiacMonitor_PrintUART(sleep_msg);
                      }

                      fsr3_release_start = 0;
                  }
              }
              else
              {
                  fsr3_release_start = 0;
              }

              fsr3_released_count = 0;
          }
      }

      osDelay(10);
  }
  /* USER CODE END StartFSRTask3 */
}

/**
  * @brief  Period elapsed callback in non blocking mode
  * @note   This function is called  when TIM6 interrupt took place, inside
  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6)
  {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
